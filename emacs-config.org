#+TITLE: emacs.d
#+STARTUP: showeverything
#+PROPERTY: header-args :cache yes :tangle yes :noweb yes

This is my GNU Emacs config file. There are many like it, but this one is mine.

** Early init

=package-initialize= should be called first, even though we do package management stuff later.

#+begin_src elisp
  (package-initialize)
#+end_src

Temporarily increase the number of bytes of cons'ing we can do before garbage collection kicks in. We don't want to run the GC until after we finish initializing.

#+begin_src elisp
  (setq gc-cons-threshold 100000000)
  (add-hook 'after-init-hook #'(lambda () (setq gc-cons-threshold 800000)))
#+end_src

By default, stuff added by Customize will show up in =init.el=, or whatever is specified by =C-h v user-init-file=. We want our =init.el= to remain simple and uncluttered, and we don't want it to contain changes that would show up in version control.

#+begin_src elisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (when (file-exists-p custom-file)
    (load custom-file :noerror))
#+end_src

If I need to, I can define variables containing sensitive information and put them into a separate file that shouldn't be checked into version control. My =.gitignore= for this repo blacklists all files except for the ones I choose to commit, and =secrets.el= is not one of them.

This does mean that I need to remember to print an error message for myself if I forget to define anything that I use later in this file.

#+begin_src elisp
  (let ((secrets-file (concat user-emacs-directory "secrets.el")))
    (when (file-exists-p secrets-file)
      (load secrets-file :noerror)))
#+end_src

** Package management

Add MELPA package archives, and refresh/install [[https://github.com/jwiegley/use-package][use-package]] if it's not already available.

#+begin_src elisp
  (unless (assoc-default "melpa" package-archives)
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t))

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (setq use-package-verbose t)
  (setq use-package-always-ensure t)
#+end_src

** Utility packages

[[https://github.com/myrjola/diminish.el][diminish.el]] hides modes (or abbreviates their names) from the modeline.

#+begin_src elisp
  (use-package diminish
    :config (diminish 'eldoc-mode))
#+end_src

=sudo-edit= allows you to enter your =sudo= password and edit (shocking, I know!) read-only files. Just invoke =M-x sudo-edit=.

#+begin_src elisp
  (use-package sudo-edit
    :defer 0.5)
#+end_src

** General behavior

By default, Emacs saves backup files in the current directory. These are the files ending in =~= that are cluttering up your directory lists. The following code stashes them all in =~/.emacs.d/backups=, where I can find them with =C-x C-f= (=find-file=) if I really need to.

#+begin_src elisp
  (unless backup-directory-alist
    (setq backup-directory-alist
          `(("." . ,(concat user-emacs-directory "backups")))))

  (setq auto-save-file-name-transforms
        `((".*" ,(concat user-emacs-directory "auto-save-list") t)))
#+end_src

Disable the creation of lockfiles, since I never have multiple users accessing the same instance of Emacs at the same time.

#+begin_src elisp
  (setq create-lockfiles nil)
#+end_src

Whenever I'm in =text-mode=, visually wrap lines without actually breaking them like =auto-fill-mode= would.

#+begin_src elisp
  (remove-hook 'text-mode-hook #'turn-on-auto-fill)
  (add-hook 'text-mode-hook 'turn-on-visual-line-mode)
#+end_src

Whenever I open a buffer, or do anything really, assume I want UTF-8 encoding instead of something silly like Latin-1.

#+begin_src elisp
  (set-charset-priority 'unicode)
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (when (display-graphic-p)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

Change "yes or no" to "y or n", because it's less typing.

#+begin_src elisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

If I start typing while I have a selection active, delete the selection like every other editor does.

#+begin_src elisp
  (delete-selection-mode t)
#+end_src

Use =display-line-numbers-mode= if it exists (Emacs 26+), otherwise use the deprecated =linum-mode=.

#+begin_src elisp
  (if (fboundp 'global-display-line-numbers-mode)
      (global-display-line-numbers-mode)
    (global-linum-mode))
#+end_src

Don't display the "Welcome to Emacs" stuff, just start in the =*scratch*= buffer. Also, make the scratch buffer empty.

#+begin_src elisp
  (setq inhibit-startup-screen t
        initial-scratch-message nil)
#+end_src

(Some of these options were adapted nearly verbatim from [[https://github.com/technomancy/better-defaults][the better-defaults project]].)

Use =ibuffer= for =C-x C-b=, which will sensibly replace the current buffer rather than forcing you to move your cursor to a completely different buffer when all you wanted to do was change the current buffer in the current frame, gosh darn it!

#+begin_src elisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

Prefer RegEx-aware search functions. The originals are still available via the =C-M= prefix.

#+begin_src elisp
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
  (global-set-key (kbd "C-M-s") 'isearch-forward)
  (global-set-key (kbd "C-M-r") 'isearch-backward)
#+end_src

Automatically refresh the buffer if the file is changed externally. It's a pain to run something like =clang-format= and then not get to see the updated buffer.

#+begin_src elisp
  (global-auto-revert-mode t)
#+end_src

Highlight pairs of parentheses.

#+begin_src elisp
  (show-paren-mode 1)
#+end_src

Disables =indent-tabs-mode= by default, so that indentation never inserts tabs. Other buffers are still able to override this behavior if needed.

#+begin_src elisp
  (setq-default indent-tabs-mode nil)
#+end_src

The following code will:

 1. Put externally-copied clipboard text in the kill buffer before
    accidentally clobbering it.
 2. Make =apropos= commands search more extensively, even though it
    might be slightly slower.
 3. Make the mouse yank at point, rather than at click.
 4. Ensure files have a final newline appended when they are saved.
 5. Flash the frame rather than ringing a "bell" to get your
    attention.
 6. If there are multiple versions of the same file available to
    =load=, it will prefer the newest version.
 7. Make =ediff= display everything in a single frame rather than
    creating a new one.

#+begin_src elisp
  (setq save-interprogram-paste-before-kill t
        apropos-do-all t
        mouse-yank-at-point t
        require-final-newline t
        visible-bell t
        load-prefer-newer t
        ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src

[[https://github.com/justbur/emacs-which-key][which-key]] displays a list of available keybindings whenever you enter a partial command prefix. For example, if I press =C-x= and then give no more input, after a fraction of a second the minibuffer will open and show me everything that I can do with that prefix.

Knowing what's even possible with this editor is critical to understanding how to use it effectively. If you don't know what keybindings exist, how will you ever know when to use them? I wish I had installed this package sooner.

#+begin_src elisp
  (use-package which-key
    :diminish
    :config (which-key-mode))
#+end_src

[[https://github.com/raxod502/selectrum][selectrum]] is an alternative to Helm, Ido, and Ivy for making incremental, narrowing selections. I'm just trying it out for now. The vanilla Emacs completion UI is a bit lackluster, so this package helps with selecting items -- files, buffers, commands, etc. -- from lists. It sounds mundane when you describe it that way, but good selection UIs are crucial for a pleasant editor experience.

It also uses the standard Emacs APIs, so there's no further configuration necessary like in Helm. Just install, enable the mode, and it's there. I'm not using any of its companion packages, like =prescient= or =consult=, until I decide I need them.

Things I need to remember when I use this package:

 - To navigate into a directory while finding a file, press =TAB= or
   =C-i=, /not/ =RET=.

It's disabled for older versions of Emacs, since according to the developers the way messages were displayed in the minibuffer was "unworkably bad."

#+begin_src elisp
  (when (>= emacs-major-version 27)
    (use-package selectrum
      :config (selectrum-mode +1)))
#+end_src

** Appearance

Disable scrollbars and the tacky menu bar. Without them, we can almost pretend this is a lean and modern editor!

#+begin_src elisp
  (unless (eq window-system 'ns)
    (menu-bar-mode -1))
  (when (fboundp 'tool-bar-mode)
    (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
  (when (fboundp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))
#+end_src

Allow custom themes to load unhindered.

#+begin_src elisp
  (setq custom-safe-themes t)
#+end_src

Dark mode colorscheme.

#+begin_src elisp
  (use-package base16-theme
    :config (load-theme 'base16-gruvbox-dark-hard t))
#+end_src

A simpler, distraction-free modeline that respects the current colorscheme.

#+begin_src elisp
  (use-package smart-mode-line
    :config (setq sml/theme 'respectful)
    (smart-mode-line-enable))
#+end_src

Emacs font heights are specified in 1/10 pt, so multiply your desired point size by 10 and you get your Emacs font height.

We also change the default font if we're on Windows, because Courier New is an abomination. Consolas has been around since Windows Vista (circa 2007), so it ought to always be available. We trust other operating systems to have a sane default font.

#+begin_src elisp
  (set-face-attribute 'default nil :height 115)

  (when (string-equal system-type "windows-nt")
    (set-face-attribute 'default nil :family "Consolas")
    (set-face-attribute 'fixed-pitch nil :family (face-attribute 'default :family)))
#+end_src

** General editing

Delete trailing whitespace when saving. The only time this gets in the way is when I'm editing someone else's poorly-formatted source code, and the stripped trailing whitespace shows up in version control.

#+begin_src elisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

Sentences in Emacs are defined to end with two spaces instead of one by default. This means that when I use a command like =M-a= or =M-e= (backward and forward sentence, respectively) or =M-k= (kill to end of sentence), I end up deleting the entire paragraph, because I never end sentences with two spaces. This code changes it to be one space, like I expect.

The [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Sentences.html][GNU documentation]] notes that this may interfere with abbreviations, but I think this is an acceptable tradeoff. I'll never use sentence-based editing commands otherwise. In fact, I didn't even know about them until I saw it in [[https://pages.sachachua.com/.emacs.d/Sacha.html][someone else's]] config. I simply thought =M-e= moved to the end of the paragraph!

Also, I really need to get into the habit of using =C-x DEL= to delete backwards to the beginning of the sentence. It's quite handy, but I'm not yet in the habit of reaching for the sentence-based text manipulation keybindings (because of the aforementioned double-space weirdness.)

#+begin_src elisp
  (setq sentence-end-double-space nil)
#+end_src

It's a little strange that you can't readily undo =M-x fill-paragraph=. This command binds =M-Q= to be the inverse of =M-q=.

#+begin_src elisp
  (defun my/unfill-paragraph (&optional region)
    "Take a multi-line paragraph and make it into a single line of text."
    (interactive (progn (barf-if-buffer-read-only) (list t)))
    (let ((fill-column (point-max))) (fill-paragraph nil region)))

  (global-set-key (kbd "M-Q") 'my/unfill-paragraph)
#+end_src

=multiple-cursors= lets you select and edit multiple pieces of text at once. It's rad.

#+begin_src elisp
  (use-package multiple-cursors
    :bind (("C-S-c C-S-c" . 'mc/edit-lines)
           ("C->" . 'mc/mark-next-like-this)
           ("C-<" . 'mc/mark-previous-like-this)
           ("C-c C-<" . 'mc/mark-all-like-this)))
#+end_src

=undo-tree= makes navigating Emacs' undo/redo history a breeze. You can view the tree with =C-x u= by default.

#+begin_src elisp
  (use-package undo-tree
    :diminish
    :config (global-undo-tree-mode))
#+end_src

** Programming

=magit= is the best Git interface I've ever used.

#+begin_src elisp
  (use-package magit
    :bind ("C-x g" . 'magit-status))
#+end_src

Enable colors for =man= pages. See [[https://emacs.stackexchange.com/a/28925][here]].

#+begin_src elisp
  (require 'man)
  (set-face-attribute 'Man-overstrike nil :inherit font-lock-type-face :bold t)
  (set-face-attribute 'Man-underline nil :inherit font-lock-keyword-face :underline t)
#+end_src

Enable ANSI color interpretation in the compilation buffer. See [[https://stackoverflow.com/a/3072831][here]].

#+begin_src elisp
  (require 'ansi-color)
  (defun colorize-compilation-buffer ()
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region (point-min) (point-max))))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+end_src

Make the compilation buffer scroll with its output.

#+begin_src elisp
  (setq compilation-scroll-output t)
#+end_src

LaTeX support.

#+begin_src elisp
  (use-package tex-mode
    :mode ("\\.(la)?tex\\'" . latex-mode)
    :ensure auctex)
#+end_src

Markdown support, with special rules for when to prefer GitHub-flavored markdown.

#+begin_src elisp
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.(md|markdown|mdown)\\'" . markdown-mode))
    :config (setq markdown-command "multimarkdown"))
#+end_src

JSON support.

#+begin_src emacs-lisp
  (use-package json-mode
    :mode "\\.json\\'")
#+end_src

YAML support.

#+begin_src elisp
  (use-package yaml-mode
    :mode "\\.ya?ml\\'")
#+end_src

TOML support.

#+begin_src elisp
  (use-package toml-mode
    :mode "\\.toml\\'")
#+end_src

CMake support.

#+begin_src elisp
  (use-package cmake-mode
    :mode "\\`CMakeLists\\.txt\\'")
#+end_src

OpenGL shader language support.

#+begin_src elisp
  (use-package glsl-mode
    :mode ("\\.glsl(v|f)?\\'" "\\.vert\\'" "\\.frag\\'" "\\.geom\\'" "\\.(v|f)s\\'"))
#+end_src

Arch Linux PKGBUILDs should be treated like normal shell scripts.

#+begin_src elisp
  (add-to-list 'auto-mode-alist '("\\`PKGBUILD\\'" . shell-script-mode))
#+end_src

Make =M-;= produce C99+ line comments rather than block comments.

#+begin_src elisp
  (add-hook 'c-mode-hook (lambda () (setq comment-start "//" comment-end "")))
#+end_src

Use =clang-format= to format C/C++ source code. This relies on there being a =.clang-format= file somewhere in or above the current directory. You can generate one based on the default styles with a command like =clang-format -style=llvm -dump-config > .clang-format=, and then tweak it to suit your needs.

The keybinding will only be available in [[https://www.gnu.org/software/emacs/manual/html_mono/ccmode.html][CC Mode]] buffers. Note that we defer adding the binding to =c-mode-base-map= until after =c-initialization-hook= is run, because otherwise, that keymap won't be defined.

#+begin_src elisp
  (use-package clang-format
    :hook (c-initialization . (lambda () (define-key c-mode-base-map (kbd "C-c C-f") 'clang-format-buffer))))
#+end_src

Rust support.

#+begin_src elisp
  (use-package rust-mode
    :mode ("\\.rs\\'" "\\.rust\\'"))
#+end_src

Language server protocol mode, and its associated UIs. By default, try to use =rust-analyzer= (rather than the older RLS) as the default LSP implementation for Rust code.

#+begin_src elisp
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook (((rust-mode c-mode c++-mode) . lsp-deferred)
           (lsp-mode . lsp-enable-which-key-integration))
    :config (setq lsp-rust-server 'rust-analyzer))

  (use-package lsp-ui
    :commands lsp-ui-mode
    :after lsp-mode)
#+end_src
